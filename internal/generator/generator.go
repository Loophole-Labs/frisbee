package generator

import (
	"fmt"
	"github.com/loophole-labs/frisbee/internal/utils"
	"google.golang.org/protobuf/compiler/protogen"
	"strings"
)

var dex = 0

const (
	fileExtension             = "_frisbee.pb.go"
	doNotEditString           = "// Code generated by frisbeegen. DO NOT EDIT."
	frisbeeImportString       = "\t\"github.com/loophole-labs/frisbee\""
	serverHandlerString       = "ServerHandler"
	clientHandlerString       = "ClientHandler"
	serverRouterString        = "ServerRouter"
	clientRouterString        = "ClientRouter"
	clientHandlerParamsString = "(incomingMessage frisbee.Message, incomingContent []byte) (outgoingMessage *frisbee.Message, outgoingContent []byte, action frisbee.Action)"
	serverHandlerParamsString = "(c *frisbee.Conn, incomingMessage frisbee.Message, incomingContent []byte) (outgoingMessage *frisbee.Message, outgoingContent []byte, action frisbee.Action)"
	messageMapString          = "messageTypes"
	messageMapTypeString      = "uint32"
)

type generator struct {
	plugin        *protogen.Plugin
	file          *protogen.File
	generatedFile *protogen.GeneratedFile
	methodNames   map[string]int
}

func New(plugin *protogen.Plugin, file *protogen.File) *generator {
	filename := file.GeneratedFilenamePrefix + fileExtension
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	return &generator{
		plugin:        plugin,
		file:          file,
		generatedFile: g,
		methodNames:   make(map[string]int),
	}
}

func (g *generator) GenerateFiles() {
	g.generateDoNotEdit()
	g.generateNeededImports()
	g.generateClientInterfaces()
	g.generateServerInterfaces()
	g.generateMethodConsts()
	g.generateClientRouterFuncs()
	g.generateServerRouterFuncs()
	g.generateNewClientContructors()
	g.generateNewServerContructors()
}

func (g *generator) p(v ...interface{}) {
	g.generatedFile.P(v...)
}

func (g *generator) generateDoNotEdit() {
	g.p(doNotEditString)
	g.p()
	g.p("package ", g.file.GoPackageName)
	g.p()
}

func (g *generator) generateNeededImports() {
	g.p("import (")
	g.p(frisbeeImportString)
	g.p(")")
}

func (g *generator) generateClientInterfaces() {
	for _, service := range g.file.Services {
		g.generateClientInterface(service)
	}
}

func (g *generator) generateClientInterface(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)
	g.p("type ", serviceName, clientHandlerString, " interface {")
	for _, method := range service.Methods {
		g.p(getClientFuncSignature(method))
	}
	g.p("}")
}

func (g *generator) generateServerInterfaces() {
	for _, service := range g.file.Services {
		g.generateServerInterface(service)
	}
}

func (g *generator) generateServerInterface(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)
	g.p("type ", serviceName, serverHandlerString, " interface {")
	for _, method := range service.Methods {
		g.p(getServerFuncSignature(method))
	}
	g.p("}")
}

func getClientFuncSignature(method *protogen.Method) string {
	methName := utils.CamelCase(method.GoName)
	return fmt.Sprintf("Handle%s"+clientHandlerParamsString, methName)
}

func getServerFuncSignature(method *protogen.Method) string {
	methName := utils.CamelCase(method.GoName)
	return fmt.Sprintf("Handle%s"+serverHandlerParamsString, methName)
}

func (g *generator) registerMethodName(method string) {
	g.methodNames[method] = dex
	dex += 1
}

func (g *generator) generateMethodConsts() {
	for _, service := range g.file.Services {
		for _, method := range service.Methods {
			methName := utils.CamelCase(method.GoName)
			g.registerMethodName(methName)
		}
	}
	kvs := make([]string, len(g.methodNames))
	for methodString, index := range g.methodNames {
		kvs[index] = fmt.Sprintf("\"%s\":%d", methodString, index+1)
	}

	g.p(fmt.Sprintf("var %s = map[string]%s{ %s }", messageMapString, messageMapTypeString, strings.Join(kvs, ",")))
}

func (g *generator) generateClientRouterFuncs() {
	for _, service := range g.file.Services {
		g.genClientRouterFunc(service)
	}
}

func (g *generator) genClientRouterFunc(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)

	g.p("func init", serviceName, clientRouterString, "( h ", serviceName, clientHandlerString, " )frisbee.ClientRouter {")
	g.p("router := make(frisbee.", clientRouterString, ")")
	for _, method := range service.Methods {
		methName := utils.CamelCase(method.GoName)
		g.p("router[", messageMapString, "[\"", methName, "\"]] = h.Handle", methName)
	}
	g.p("return router")
	g.p("}")
}

func (g *generator) generateServerRouterFuncs() {
	for _, service := range g.file.Services {
		g.generateServerRouterFunc(service)
	}
}

func (g *generator) generateServerRouterFunc(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)

	g.p("func init", serviceName, serverRouterString, "( h ", serviceName, serverHandlerString, " )frisbee.ServerRouter {")
	g.p("router := make(frisbee.", serverRouterString, ")")
	for _, method := range service.Methods {
		methName := utils.CamelCase(method.GoName)
		g.p("router[", messageMapString, "[\"", methName, "\"]] = h.Handle", methName)
	}
	g.p("return router")
	g.p("}")
}

func (g *generator) generateNewClientContructors() {
	for _, service := range g.file.Services {
		g.generateNewClientContructor(service)
	}
}

func (g *generator) generateNewClientContructor(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)
	g.p("func NewClient(addr string, h ", serviceName, clientHandlerString, ", opts ...frisbee.Option) *frisbee.Client {")
	g.p("return frisbee.NewClient(addr, init", serviceName, clientRouterString, "(h), opts...)")
	g.p("}")
}

func (g *generator) generateNewServerContructors() {
	for _, service := range g.file.Services {
		g.genNewServerContructor(service)
	}
}

func (g *generator) genNewServerContructor(service *protogen.Service) {
	serviceName := utils.CamelCase(service.GoName)
	g.p("func NewServer(addr string, h ", serviceName, serverHandlerString, ", opts ...frisbee.Option) *frisbee.Server {")
	g.p("return frisbee.NewServer(addr, init", serviceName, serverRouterString, "(h), opts...)")
	g.p("}")
}
