{{define "client"}}
type Client struct {
    *frisbee.Client
    {{ range $i, $v := (MakeIterable .services.Len) -}}
        {{ $service := $.services.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
            {{ $method := $service.Methods.Get $i -}}
            next{{ CamelCaseName $method.Name }} uint16
            next{{ CamelCaseName $method.Name }}Mu sync.RWMutex
            inflight{{ CamelCaseName $method.Name }}Mu sync.RWMutex
            {{ if $method.IsStreamingServer}}
            inflight{{ CamelCaseName $method.Name }} map[uint16]*queue.Circular[{{ CamelCase $method.Output.FullName }}, *{{ CamelCase $method.Output.FullName }}]
            {{else -}}
            inflight{{ CamelCaseName $method.Name }} map[uint16]chan *{{ CamelCase $method.Output.FullName }}
            {{end -}}
        {{end -}}
    {{end -}}
}

func NewClient (tlsConfig *tls.Config, logger *zerolog.Logger) (*Client, error) {
    c := new(Client)
    table := make(frisbee.HandlerTable)
    {{template "clienthandlers" .services -}}

    var err error
    if tlsConfig != nil {
        c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
        if err != nil {
            return nil, err
        }
    } else {
        c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
        if err != nil {
            return nil, err
        }
    }

    {{ range $i, $v := (MakeIterable .services.Len) -}}
        {{ $service := $.services.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
            {{ $method := $service.Methods.Get $i -}}
                c.next{{ CamelCaseName $method.Name }} = 0
                {{ if $method.IsStreamingServer -}}
                c.inflight{{ CamelCaseName $method.Name }} = make(map[uint16]*queue.Circular[{{ CamelCase $method.Output.FullName }}, *{{ CamelCase $method.Output.FullName }}])
                {{else -}}
                c.inflight{{ CamelCaseName $method.Name }} = make(map[uint16]chan *{{ CamelCase $method.Output.FullName }})
                {{end -}}
        {{end -}}
    {{end -}}
    return c, nil
}

{{template "clientmethods" .services }}
{{end}}

{{define "clienthandlers"}}
{{ $counter := Counter 9 -}}
{{ range $i, $v := (MakeIterable .Len) }}
    {{ $service := $.Get $i -}}
    {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
        {{ $method := $service.Methods.Get $i -}}
        {{ $count := call $counter -}}
        table[{{ $count }}] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
            {{ if $method.IsStreamingServer -}}
            res := New{{ CamelCase $method.Output.FullName }}()
            err := res.Decode(incoming.Content.B)
            if err == nil {
                c.inflight{{ CamelCaseName $method.Name }}Mu.RLock()
                if q, ok := c.inflight{{ CamelCaseName $method.Name }}[incoming.Metadata.Id]; ok {
                    c.inflight{{ CamelCaseName $method.Name }}Mu.RUnlock()
                    err := q.Push(res)
                    if err != nil {
                        return nil, 0
                    }
                } else {
                    c.inflight{{ CamelCaseName $method.Name }}Mu.RUnlock()
                }
            }
            {{else -}}
            c.inflight{{ CamelCaseName $method.Name }}Mu.RLock()
            if ch, ok := c.inflight{{ CamelCaseName $method.Name }}[incoming.Metadata.Id]; ok {
                c.inflight{{ CamelCaseName $method.Name }}Mu.RUnlock()
                res := New{{ CamelCase $method.Output.FullName }}()
                res.Decode(incoming.Content.B)
                ch <- res
            } else {
                c.inflight{{ CamelCaseName $method.Name }}Mu.RUnlock()
            }
            {{end -}}
            return
        }
    {{end -}}
{{end -}}
{{end}}

{{define "clientmethods"}}
{{ $counter := Counter 9 -}}
{{ range $i, $v := (MakeIterable .Len) -}}
    {{ $service := $.Get $i -}}
    {{ range $i, $v := (MakeIterable $service.Methods.Len) }}
        {{ $method := $service.Methods.Get $i -}}
        {{ $opIndex := call $counter -}}
        {{if or $method.IsStreamingClient $method.IsStreamingServer -}}
            func (c *Client) {{ CamelCaseName $method.Name }}(ctx context.Context, req *{{ CamelCase $method.Input.FullName }}) (*{{ CamelCaseName $method.Name }}Client, error) {
                p := packet.Get()
                p.Metadata.Operation = {{ $opIndex }}

                c.next{{ CamelCaseName $method.Name }}Mu.Lock()
                c.next{{ CamelCaseName $method.Name }} += 1
                id := c.next{{ CamelCaseName $method.Name }}
                c.next{{ CamelCaseName $method.Name }}Mu.Unlock()
                p.Metadata.Id = id

                req.Encode(p)
                p.Metadata.ContentLength = uint32(len(p.Content.B))
                err := c.Client.WritePacket(p)

                {{ if $method.IsStreamingServer -}}
                q := queue.NewCircular[{{ CamelCase $method.Output.FullName }}, *{{ CamelCase $method.Output.FullName }}](100)
                stale := make([]*Count, 0)
                staleMu := sync.Mutex{}

                c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                c.inflight{{ CamelCaseName $method.Name }}[p.Metadata.Id] = q
                c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                {{ end -}}

                if err != nil {
                    packet.Put(p)
                    return nil, err
                }
                packet.Put(p)

                stream := {{ CamelCaseName $method.Name }}Client{
                    context: ctx,
                    closed: atomic.NewBool(false),
                }

                {{ if $method.IsStreamingServer }}
                stream.recv = func() (*{{ CamelCase $method.Output.FullName }}, error) {
                    if stream.closed.Load() {
                        staleMu.Lock()
                        if len(stale) > 0 {
                            var r *Count
                            r, stale = stale[0], stale[1:]
                            staleMu.Unlock()
                            return r, nil
                        }
                        staleMu.Unlock()
                        return nil, io.EOF
                    }

                    if c.Closed() {
                        stream.close()
                    }

                    readPacket, err := q.Pop()
                    if err != nil {
                        if stream.closed.Load() {
                            staleMu.Lock()
                            if len(stale) > 0 {
                                var r *Count
                                r, stale = stale[0], stale[1:]
                                staleMu.Unlock()
                                return r, nil
                            }
                            staleMu.Unlock()
                        }
                        return nil, io.EOF
                    }
                    return readPacket, nil
                }
                stream.close = func () {
                    staleMu.Lock()
                    stream.closed.Store(true)
                    stale = q.Drain()
                    staleMu.Unlock()
                    q.Close()
                }
                {{ else if $method.IsStreamingClient }}
                    ch := make(chan *{{ CamelCase $method.Output.FullName }}, 1)
                    c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                    c.inflight{{ CamelCaseName $method.Name }}[p.Metadata.Id] = ch
                    c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()

                    stream.recv = func () (res *{{ CamelCase $method.Output.FullName }}, err error) {
                        select {
                        case res = <- ch:
                            err = res.error
                        case <- ctx.Done():
                            err = ctx.Err()
                        }
                        c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                        delete(c.inflight{{ CamelCaseName $method.Name }}, p.Metadata.Id)
                        c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                        return
                    }
                {{ end -}}

                {{ if $method.IsStreamingClient -}}
                stream.send = func (m *{{ CamelCase $method.Input.FullName }}) error {
                    p := packet.Get()
                    p.Metadata.Operation = {{ $opIndex }}

                    p.Metadata.Id = id

                    m.Encode(p)
                    p.Metadata.ContentLength = uint32(len(p.Content.B))
                    err := c.WritePacket(p)
                    if err != nil {
                        packet.Put(p)
                        return err
                    }
                    packet.Put(p)
                    return nil
                }
                {{ end -}}
                go func () {
                <-ctx.Done()
                    c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                    delete(c.inflight{{ CamelCaseName $method.Name }}, p.Metadata.Id)
                    c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                }()
                return &stream, nil
            }

        type {{ CamelCaseName $method.Name }}Client struct {
            context context.Context
            recv func() (*{{ CamelCase $method.Output.FullName }}, error)
            close func()
            closed *atomic.Bool

            {{ if $method.IsStreamingClient -}}
            send func (*{{ CamelCase $method.Input.FullName }}) error
            {{ end -}}
        }

        {{ if $method.IsStreamingServer -}}
        func (x *{{ CamelCaseName $method.Name }}Client) Recv() (*{{ CamelCase $method.Output.FullName }}, error) {
            return x.recv()
        }
       {{ end -}}

       {{ if $method.IsStreamingClient -}}
        func (x *{{ CamelCaseName $method.Name }}Client) Send(m *{{ CamelCase $method.Input.FullName }}) error {
            return x.send(m)
        }

        func (x *{{ CamelCaseName $method.Name }}Client) CloseSend() error {
            r := {{ CamelCase $method.Input.FullName }}{flags: SetCloseFlag(0, true) }
            return x.Send(&r)
        }

        func (x *{{ CamelCaseName $method.Name }}Client) CloseAndRecv() (*{{ CamelCase $method.Output.FullName }}, error) {
            r := {{ CamelCase $method.Input.FullName }}{flags: SetCloseFlag(0, true) }
            x.Send(&r)
            return x.recv()
        }
        {{ end -}}
        {{else -}}
        func (c *Client) {{ CamelCaseName $method.Name }}(ctx context.Context, req *{{ CamelCase $method.Input.FullName }}) (res *{{ CamelCase $method.Output.FullName }}, err error) {
            ch := make(chan *{{ CamelCase $method.Output.FullName }}, 1)
            p := packet.Get()
            p.Metadata.Operation = {{ $opIndex }}

            c.next{{ CamelCaseName $method.Name }}Mu.Lock()
            c.next{{ CamelCaseName $method.Name }} += 1
            p.Metadata.Id = c.next{{ CamelCaseName $method.Name }}
            c.next{{ CamelCaseName $method.Name }}Mu.Unlock()

            req.Encode(p)
            p.Metadata.ContentLength = uint32(len(p.Content.B))
            c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
            c.inflight{{ CamelCaseName $method.Name }}[p.Metadata.Id] = ch
            c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
            err = c.Client.WritePacket(p)
            if err != nil {
                packet.Put(p)
                return
            }
            select {
                case res = <- ch:
                    err = res.error
                case <- ctx.Done():
                    err = ctx.Err()
            }
            c.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
            delete(c.inflight{{ CamelCaseName $method.Name }}, p.Metadata.Id)
            c.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
            packet.Put(p)
            return
        }
    {{end -}}
{{end -}}
{{end -}}
{{end}}