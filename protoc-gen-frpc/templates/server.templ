{{define "server"}}
type Server struct {
    *frisbee.Server

    {{ range $i, $v := (MakeIterable .services.Len) -}}
        {{ $service := $.services.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
            {{ $method := $service.Methods.Get $i -}}
            {{ if $method.IsStreamingClient}}
                next{{ CamelCaseName $method.Name }}       uint16
                next{{ CamelCaseName $method.Name }}Mu sync.RWMutex
                inflight{{ CamelCaseName $method.Name }}Mu sync.RWMutex
                inflight{{ CamelCaseName $method.Name }} map[uint16]*queue.Circular[{{ CamelCase $method.Input.FullName }}, *{{ CamelCase $method.Input.FullName }}]
            {{end -}}
        {{end -}}
    {{end -}}
}

func NewServer({{ GetServerFields .services }}, tlsConfig *tls.Config, logger *zerolog.Logger) (*Server, error) {
        var s *Server
        table := make(frisbee.HandlerTable)
        {{template "serverhandlers" .services -}}
        var fsrv *frisbee.Server
        var err error
        if tlsConfig != nil {
            fsrv, err = frisbee.NewServer(table, frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
            if err != nil {
                return nil, err
            }
        } else {
            fsrv, err = frisbee.NewServer(table, frisbee.WithLogger(logger))
            if err != nil {
                return nil, err
            }
        }

        fsrv.ConnContext = func (ctx context.Context, conn *frisbee.Async) context.Context {
            return context.WithValue(ctx, "conn", conn)
        }
        s, err = &Server{
            Server: fsrv,
        }, nil

        {{ range $i, $v := (MakeIterable .services.Len) -}}
            {{ $service := $.services.Get $i -}}
            {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
                {{ $method := $service.Methods.Get $i -}}
                {{ if $method.IsStreamingClient -}}
                s.next{{ CamelCaseName $method.Name }} = 0
                s.inflight{{ CamelCaseName $method.Name }} = make(map[uint16]*queue.Circular[{{ CamelCase $method.Input.FullName }}, *{{ CamelCase $method.Input.FullName }}])
                {{end -}}
            {{end -}}
        {{end -}}
        return s, err
    }

{{template "servermethods" .services }}
{{end}}

{{define "servermethods"}}
{{ $counter := Counter 9 -}}
    {{ range $i, $v := (MakeIterable .Len) -}}
        {{ $service := $.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) }}
            {{ $method := $service.Methods.Get $i -}}
            {{ $opIndex := call $counter -}}
            {{if or $method.IsStreamingClient $method.IsStreamingServer -}}
                type {{ CamelCaseName $method.Name }}Server struct {
                    context context.Context
                    recv func() (*{{ CamelCase $method.Input.FullName }}, error)
                    send func (*{{ CamelCase $method.Output.FullName }}) error
                }

                func (x *{{ CamelCaseName $method.Name }}Server) Context() context.Context {
                    return x.context
                }

                {{ if $method.IsStreamingClient -}}
                func (x *{{ CamelCaseName $method.Name }}Server) Recv() (*{{ CamelCase $method.Input.FullName }}, error) {
                    return x.recv()
                }
                {{ end -}}

                {{ if $method.IsStreamingServer -}}
                func (x *{{ CamelCaseName $method.Name }}Server) Send(m *{{ CamelCase $method.Output.FullName }}) error {
                    return x.send(m)
                }
                {{ end -}}

                {{ if or $method.IsStreamingClient $method.IsStreamingServer -}}
                func (x *EchoStreamServer) CloseAndSend(m *{{ CamelCase $method.Output.FullName }}) error {
                    m.flags = 1
                    return x.send(m)
                }
                {{ end -}}
            {{end -}}
        {{end -}}
    {{end -}}
{{end}}

{{define "serverhandlers"}}
    {{ $counter := Counter 9 -}}
    {{ range $i, $v := (MakeIterable .Len) -}}
        {{ $service := $.Get $i -}}
        {{ range $i, $v := (MakeIterable $service.Methods.Len) -}}
            {{ $method := $service.Methods.Get $i -}}
            {{ $count := call $counter -}}
            table[{{ $count }}] = func(ctx context.Context, incoming *packet.Packet) (outgoing *packet.Packet, action frisbee.Action) {
                req := New{{ CamelCase $method.Input.FullName  }}()
                err := req.Decode(incoming.Content.B)
                if err == nil {
                {{ if or $method.IsStreamingClient $method.IsStreamingServer -}}
                    {{ if $method.IsStreamingClient -}}
                    s.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                    if q, ok := s.inflight{{ CamelCaseName $method.Name }}[incoming.Metadata.Id]; ok {
                        q.Push(req)
                        s.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                    } else {
                        q := queue.NewCircular[{{ CamelCase $method.Input.FullName  }}, *{{ CamelCase $method.Input.FullName  }}](100)
                        s.inflight{{ CamelCaseName $method.Name }}[incoming.Metadata.Id] = q
                        q.Push(req)
                        s.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                        {{ end -}}


                        {{ if $method.IsStreamingServer -}}
                        id := incoming.Metadata.Id
                        conn := ctx.Value("conn").(*frisbee.Async)
                        {{ end -}}

                        {{ if $method.IsStreamingClient -}}
                        recv := func() (*{{ CamelCase $method.Input.FullName }}, error) {
                            p, err := q.Pop()
                            if p.flags == 1 {
                                return nil, io.EOF
                            }
                            return p, err
                        }
                        {{ end -}}

                        {{ if $method.IsStreamingServer}}
                        send := func (m *{{ CamelCase $method.Output.FullName }}) error {
                            p := packet.Get()
                            p.Metadata.Operation = {{ $count }}

                            p.Metadata.Id = id

                            m.Encode(p)
                            p.Metadata.ContentLength = uint32(len(p.Content.B))
                            err := conn.WritePacket(p)
                            if err != nil {
                                packet.Put(p)
                                return err
                            }
                            packet.Put(p)
                            return nil
                        }
                        {{ end -}}

                        srv := {{ CamelCaseName $method.Name }}Server{
                            context: ctx,
                            {{ if $method.IsStreamingClient -}}recv: recv, {{ end -}}
                            {{ if $method.IsStreamingServer -}}send: send, {{ end -}}
                        }
                        go func() {
                            err := {{ FirstLowerCaseName $service.Name }}.{{ CamelCaseName $method.Name }}(srv)
                            if err != nil {
                                res := {{ CamelCase $method.Output.FullName }}{error: err}
                                srv.CloseAndSend(&res)
                            } else {
                                res := {{ CamelCase $method.Output.FullName }}{}
                                srv.CloseAndSend(&res)
                            }
                            {{ if $method.IsStreamingClient -}}
                            s.inflight{{ CamelCaseName $method.Name }}Mu.Lock()
                            s.inflight{{ CamelCaseName $method.Name }}[incoming.Metadata.Id] = nil
                            s.inflight{{ CamelCaseName $method.Name }}Mu.Unlock()
                            {{ end -}}
                        }()
                        {{ end -}}
                        {{ if $method.IsStreamingClient }}
                    }
                        {{ end -}}
                {{ if not (or $method.IsStreamingServer $method.IsStreamingClient) -}}
                    var res *{{ CamelCase $method.Output.FullName }}
                    outgoing = incoming
                    outgoing.Content.Reset()
                    res, err = {{ FirstLowerCase (CamelCaseName $service.Name) }}.{{ CamelCaseName $method.Name }}(ctx, req)
                    if err != nil {
                        res.Error(outgoing, err)
                    } else {
                        res.Encode(outgoing)
                    }
                    outgoing.Metadata.ContentLength = uint32(len(outgoing.Content.B))
                {{end -}}
                }
                return
            }
        {{end -}}
    {{end -}}
{{end}}